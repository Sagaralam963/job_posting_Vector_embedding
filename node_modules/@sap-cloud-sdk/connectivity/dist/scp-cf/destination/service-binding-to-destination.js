"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serviceToDestinationTransformers = void 0;
exports.transformServiceBindingToDestination = transformServiceBindingToDestination;
exports.transformServiceBindingToClientCredentialsDestination = transformServiceBindingToClientCredentialsDestination;
const token_accessor_1 = require("../token-accessor");
const jwt_1 = require("../jwt");
const identity_service_1 = require("../identity-service");
const client_credentials_token_cache_1 = require("../client-credentials-token-cache");
const subdomain_replacer_1 = require("../subdomain-replacer");
/**
 * @internal
 */
exports.serviceToDestinationTransformers = {
    'business-logging': businessLoggingBindingToDestination,
    's4-hana-cloud': xfS4hanaCloudBindingToDestination,
    destination: destinationBindingToDestination,
    'saas-registry': saasRegistryBindingToDestination,
    workflow: workflowBindingToDestination,
    'service-manager': serviceManagerBindingToDestination,
    xsuaa: xsuaaToDestination,
    aicore: aicoreToDestination,
    identity: transformIasBindingToDestination
};
/**
 * Convenience function to create a destination from the provided service binding.
 * If a JWT is provided as part of options, the tenant in the JWT is used for client credentials grant, else the provider tenant is used, wherever applicable.
 * Supported service types are:
 * - business-logging (OAuth2ClientCredentials)
 * - destination (OAuth2ClientCredentials)
 * - s4-hana-cloud (BasicAuthentication)
 * - saas-registry (OAuth2ClientCredentials)
 * - workflow (OAuth2ClientCredentials)
 * - service-manager (OAuth2ClientCredentials)
 * - xsuaa (OAuth2ClientCredentials)
 * - aicore (OAuth2ClientCredentials)
 * - identity (OAuth2ClientCredentials with mTLS or client secret)
 * Throws an error if the provided service binding is not supported.
 * @param serviceBinding - The service binding to transform.
 * @param options - Options used for fetching the destination.
 * @returns A promise returning the transformed destination on success.
 */
async function transformServiceBindingToDestination(serviceBinding, options) {
    if (exports.serviceToDestinationTransformers[serviceBinding.label]) {
        return exports.serviceToDestinationTransformers[serviceBinding.label](serviceBinding, options);
    }
    throw new Error(`The provided service binding of type ${serviceBinding.label} is not supported out of the box for destination transformation.`);
}
/**
 * Convenience function to create a destination from the provided service binding.
 * Transforms a service binding to a destination of type OAuth2ClientCredentials.
 * If a JWT is provided as part of the options, the tenant in the JWT is used for the client credentials grant, else the provider tenant is used, wherever applicable.
 * @param service - The service binding to transform.
 * @param options - Options used to transform the service binding.
 * @returns A promise returning the transformed destination on success.
 */
async function transformServiceBindingToClientCredentialsDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, options?.url ?? service.url, service.name);
}
async function aicoreToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, service.credentials.serviceurls.AI_API_URL, service.name);
}
async function xsuaaToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, service.credentials.apiurl, service.name);
}
async function serviceManagerBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, service.credentials.sm_url, service.name);
}
async function destinationBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, service.credentials.uri, service.name);
}
async function saasRegistryBindingToDestination(service, options) {
    const token = await (0, token_accessor_1.serviceToken)(service, options);
    return buildDestination(token, service.credentials['saas_registry_url'], service.name);
}
async function businessLoggingBindingToDestination(service, options) {
    const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
    };
    const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
    return buildDestination(token, service.credentials.writeUrl, service.name);
}
async function workflowBindingToDestination(service, options) {
    const transformedService = {
        ...service,
        credentials: { ...service.credentials.uaa }
    };
    const token = await (0, token_accessor_1.serviceToken)(transformedService, options);
    return buildDestination(token, service.credentials.endpoints.workflow_odata_url, service.name);
}
async function xfS4hanaCloudBindingToDestination(service) {
    return {
        url: service.credentials.URL,
        authentication: 'BasicAuthentication',
        username: service.credentials.User,
        password: service.credentials.Password
    };
}
/**
 * Tries to resolve `app_tid` based on supplied IAS options.
 * @param iasOptions - IAS technical user options.
 * @param service - Service binding for identity service.
 * @param options - Service binding transform options.
 * @returns The BTP app_tid based on `requestAs` configuration.
 */
function getIasAppTid(iasOptions, service, options) {
    const { requestAs } = iasOptions;
    if (requestAs === 'provider-tenant') {
        return service.app_tid;
    }
    if (requestAs === 'current-tenant' || !requestAs) {
        return options?.jwt?.app_tid;
    }
    requestAs;
    throw new Error(`Invalid requestAs value: ${requestAs}`);
}
/**
 * Builds destination based on supplied IAS options.
 * Uses `targetUrl` as the destination URL if supplied and adds `mtlsKeyPair` if available.
 * @param accessToken - The JWT token to access the service.
 * @param service - Service binding for identity service.
 * @param iasOptions - IAS options to build the destination.
 * @returns A destination object.
 */
function buildIasDestination(accessToken, service, iasOptions) {
    const destination = buildDestination(accessToken, iasOptions?.targetUrl ?? service.credentials.url, service.name, iasOptions.authenticationType || 'OAuth2ClientCredentials');
    // Add mTLS key pair if available
    if (service.credentials.certificate && service.credentials.key) {
        destination.mtlsKeyPair = {
            cert: service.credentials.certificate,
            key: service.credentials.key
        };
    }
    return destination;
}
async function transformIasBindingToDestination(service, options) {
    const iasOptions = {
        authenticationType: 'OAuth2ClientCredentials',
        useCache: options?.useCache !== false,
        ...(options?.iasOptions || {})
    };
    const iasInstance = (0, subdomain_replacer_1.parseUrlAndGetHost)(service.credentials.url);
    // Technical user client credentials grant preperation
    if (iasOptions.authenticationType === 'OAuth2ClientCredentials') {
        if (!iasOptions.appTid) {
            iasOptions.appTid = getIasAppTid(iasOptions, service, options);
        }
        if (iasOptions.useCache) {
            const cached = client_credentials_token_cache_1.clientCredentialsTokenCache.getTokenIas({
                iasInstance,
                appTid: iasOptions.appTid,
                clientId: service.credentials.clientid,
                resource: options?.iasOptions?.resource
            });
            if (cached) {
                return buildIasDestination(cached.access_token, service, iasOptions);
            }
        }
    }
    const response = await (0, identity_service_1.getIasToken)(service, {
        jwt: options?.jwt,
        ...iasOptions
    });
    if (iasOptions.authenticationType === 'OAuth2ClientCredentials' &&
        iasOptions.useCache &&
        response) {
        client_credentials_token_cache_1.clientCredentialsTokenCache.cacheIasToken({
            iasInstance,
            appTid: iasOptions.appTid,
            clientId: service.credentials.clientid,
            resource: iasOptions?.resource
        }, response);
    }
    return buildIasDestination(response.access_token, service, iasOptions);
}
/**
 * Builds a destination object with a token, name, and url.
 * If no authentication type is provided, 'OAuth2ClientCredentials' is used by default.
 * @internal
 * @param token - The access token for the destination.
 * @param url - The URL of the destination.
 * @param name - The name of the destination.
 * @param authentication - The authentication type for the destination. Defaults to 'OAuth2ClientCredentials'.
 * @returns A destination object.
 */
function buildDestination(token, url, name, authentication = 'OAuth2ClientCredentials') {
    const expirationTime = (0, jwt_1.decodeJwt)(token).exp;
    const expiresIn = expirationTime
        ? Math.floor((expirationTime * 1000 - Date.now()) / 1000).toString(10)
        : undefined;
    return {
        url,
        name,
        authentication,
        authTokens: [
            {
                value: token,
                type: 'bearer',
                expiresIn,
                http_header: { key: 'Authorization', value: `Bearer ${token}` },
                error: null
            }
        ]
    };
}
//# sourceMappingURL=service-binding-to-destination.js.map