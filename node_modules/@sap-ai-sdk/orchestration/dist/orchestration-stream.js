import { SseStream } from '@sap-ai-sdk/core';
import { OrchestrationStreamChunkResponse } from './orchestration-stream-chunk-response.js';
import { mergeStreamResponse } from './util/index.js';
/**
 * Orchestration stream containing post-processing functions.
 */
export class OrchestrationStream extends SseStream {
    iterator;
    /**
     * Create an orchestration stream based on the http response.
     * @param response - Http response.
     * @returns An orchestration stream.
     * @internal
     */
    static _create(response, controller) {
        const stream = SseStream.transformToSseStream(response, controller);
        return new OrchestrationStream(stream.iterator, controller);
    }
    /**
     * Wrap raw chunk data with chunk response class to provide helper functions.
     * @param stream - Orchestration stream.
     * @internal
     */
    static async *_processChunk(stream) {
        for await (const chunk of stream) {
            yield new OrchestrationStreamChunkResponse(chunk);
        }
    }
    static async *_processOrchestrationStreamChunkResponse(stream, response) {
        if (!response) {
            throw new Error('Response is required to process completion post response streaming.');
        }
        for await (const chunk of stream) {
            mergeStreamResponse(response, chunk._data);
            yield chunk;
        }
    }
    static async *_processStreamEnd(stream, response) {
        if (!response) {
            throw new Error('Response is required to process stream end.');
        }
        for await (const chunk of stream) {
            yield chunk;
        }
        response._openStream = false;
    }
    /**
     * Transform a stream of chunks into a stream of content strings.
     * @param stream - Orchestration stream.
     * @param choiceIndex - The index of the choice to parse.
     * @internal
     */
    static async *_processContentStream(stream) {
        for await (const chunk of stream) {
            const deltaContent = chunk.getDeltaContent();
            if (!deltaContent) {
                continue;
            }
            yield deltaContent;
        }
    }
    constructor(iterator, controller) {
        super(iterator, controller);
        this.iterator = iterator;
    }
    /**
     * Pipe the stream through a processing function.
     * @param processFn - The function to process the input stream.
     * @param response - The `OrchestrationStreamResponse` object for process function to store finish reason, token usage, etc.
     * @returns The output stream containing processed items.
     * @internal
     */
    _pipe(processFn, response) {
        if (response) {
            return new OrchestrationStream(() => processFn(this, response), this.controller);
        }
        return new OrchestrationStream(() => processFn(this), this.controller);
    }
    /**
     * Transform the stream of chunks into a stream of content strings.
     * @param this - Orchestration stream.
     * @returns A stream of content strings.
     */
    toContentStream() {
        return new OrchestrationStream(() => OrchestrationStream._processContentStream(this), this.controller);
    }
}
//# sourceMappingURL=orchestration-stream.js.map